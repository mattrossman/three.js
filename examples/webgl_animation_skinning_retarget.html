<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - animation - skinning - retarget</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="author" content="Antoine BERNIER (abernier)" />
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
		body {color:white;}
		#info a {
			color:#4d6675;
		}
		</style>
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl - animation retargeting<br />
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
		</script>

		<script type="module">
		import * as THREE from 'three';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { TransformControls } from 'three/addons/controls/TransformControls.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
		import { CCDIKSolver, CCDIKHelper } from './jsm/animation/CCDIKSolver.js';
		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js'

		let scene, camera, renderer, orbitControls, clock;

		let stats, gui, params;

		let mixer, skeletonSource, skeletonTarget, retargetOptions;

		const _color = new THREE.Color();

		const axesMaterial = new THREE.LineBasicMaterial({ vertexColors: true, toneMapped: false, depthTest: false });

		init().then( animate );

		async function init() {

			params = {
				animate: true,
				retarget: true,
				update: updateRetarget,
				poseSource: () => { skeletonSource.pose() }
			}

			clock = new THREE.Clock();

			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xa0a0a0 );
			scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

			camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.001, 5000 );
			camera.position.set( 1, 2, 3 );

			const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
			hemiLight.position.set( 0, 20, 0 );
			scene.add( hemiLight );

			const dirLight = new THREE.DirectionalLight( 0xffffff );
			dirLight.position.set( - 3, 10, - 10 );
			dirLight.castShadow = true;
			dirLight.shadow.camera.top = 2;
			dirLight.shadow.camera.bottom = - 2;
			dirLight.shadow.camera.left = - 2;
			dirLight.shadow.camera.right = 2;
			dirLight.shadow.camera.near = 0.1;
			dirLight.shadow.camera.far = 40;
			scene.add( dirLight );

			// ground

			const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
			mesh.rotation.x = - Math.PI / 2;
			mesh.receiveShadow = true;
			scene.add( mesh );

			const grid = new THREE.GridHelper();
			scene.add(grid);

			const gltfLoader = new GLTFLoader();
			const bvhLoader = new BVHLoader();

			const [ bvh, gltf ] = await Promise.all([

				bvhLoader.loadAsync( 'models/bvh/pirouette.bvh' ),

				gltfLoader.loadAsync( 'models/gltf/Soldier.glb' )

			] );

			gltf.scene.traverse( (object) => {

				if ( object.isMesh ) object.castShadow = true;

			} );

			scene.add( gltf.scene );

			const sourceHelper = new THREE.SkeletonHelper( bvh.skeleton.bones[0] );
			sourceHelper.skeleton = bvh.skeleton; // HACK
			scene.add( sourceHelper );

			const targetHelper = new THREE.SkeletonHelper( gltf.scene );
			setSkeletonHelperColors( targetHelper, 'red', 'red' );
			scene.add(targetHelper)

			const container = new THREE.Group();
			container.scale.setScalar( 0.01 );
			container.add( bvh.skeleton.bones[0] );

			scene.add( container );

			skeletonSource = bvh.skeleton;
			skeletonTarget = gltf.scene.getObjectByProperty('isSkinnedMesh', true).skeleton;

			skeletonTarget.bones[ 0 ].updateMatrixWorld();

			// Save T bind pose
			skeletonSource.bones[ 0 ].updateMatrixWorld();
			skeletonSource.calculateInverses();

			{
				const axes = new THREE.AxesHelper(10);
				axes.material.depthTest = false;
				skeletonTarget.bones[ 0 ].add( axes ); 
			}

			mixer = new THREE.AnimationMixer( sourceHelper );
			mixer.clipAction( bvh.clip ).setEffectiveWeight( 1.0 ).play();

			retargetOptions = {
				hip: "hip",
				names: {
					"mixamorigHips": "hip",
					"mixamorigSpine": "abdomen",
					"mixamorigSpine1": "Chest2",
					"mixamorigSpine2": "Chest3",
					"mixamorigNeck": "neck",
					"mixamorigHead": "head",
					"mixamorigRightShoulder": "rCollar",
					"mixamorigRightArm": "rShldr",
					"mixamorigRightForeArm": "rForeArm",
					"mixamorigRightHand": "rHand",
					"mixamorigRightHandThumb1": "rThumb1",
					"mixamorigRightHandThumb2": "rThumb2",
					"mixamorigRightHandIndex1": "rIndex1",
					"mixamorigRightHandIndex2": "rIndex2",
					"mixamorigRightHandMiddle1": "rMid1",
					"mixamorigRightHandMiddle2": "rMid2",
					"mixamorigRightHandRing1": "rRing1",
					"mixamorigRightHandRing2": "rRing2",
					"mixamorigRightHandPinky1": "rPinky1",
					"mixamorigRightHandPinky2": "rPinky2",
					"mixamorigLeftShoulder": "lCollar",
					"mixamorigLeftArm": "lShldr",
					"mixamorigLeftForeArm": "lForeArm",
					"mixamorigLeftHand": "lHand",
					"mixamorigLeftHandThumb1": "lThumb1",
					"mixamorigLeftHandThumb2": "lThumb2",
					"mixamorigLeftHandIndex1": "lIndex1",
					"mixamorigLeftHandIndex2": "lIndex2",
					"mixamorigLeftHandMiddle1": "lMid1",
					"mixamorigLeftHandMiddle2": "lMid2",
					"mixamorigLeftHandRing1": "lRing1",
					"mixamorigLeftHandRing2": "lRing2",
					"mixamorigLeftHandPinky1": "lPinky1",
					"mixamorigLeftHandPinky2": "lPinky2",
					"mixamorigRightUpLeg": "rThigh",
					"mixamorigRightLeg": "rShin",
					"mixamorigRightFoot": "rFoot",
					"mixamorigLeftUpLeg": "lThigh",
					"mixamorigLeftLeg": "lShin",
					"mixamorigLeftFoot": "lFoot",
				}
			};

			renderer = new THREE.WebGLRenderer( { antialias: true, logarithmicDepthBuffer: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			stats = new Stats();
			document.body.appendChild( stats.dom );

			orbitControls = new OrbitControls( camera, renderer.domElement );
			orbitControls.target.set(0, 1, 0)
			orbitControls.enableDamping = true;

			gui = new GUI();
			gui.add( params, 'animate' );
			gui.add( params, 'retarget' );
			gui.add( params, 'update' );
			gui.add( params, 'poseSource' );
			gui.open();

			window.addEventListener( 'resize', onWindowResize, false );

			Object.assign(window, {
				THREE, gltf, bvh, skeletonSource, skeletonTarget,
				m: new THREE.Matrix4(), e: new THREE.Euler(),
				p: new THREE.Vector3(), s: new THREE.Vector3(), q: new THREE.Quaternion,
			})

		}

		function animate( ) {

			requestAnimationFrame( animate );

			const delta = clock.getDelta();

			if (params.animate) mixer.update(delta);

			if (params.retarget) updateRetarget()
			// SkeletonUtils.retarget(skeletonTarget, skeletonSource, retargetOptions)

			orbitControls.update();

			stats.update();

			renderer.render( scene, camera );

		}

		function updateRetarget() {

			// SkeletonUtils.retarget(skeletonTarget, skeletonSource, retargetOptions)
			SkeletonUtils.retargetV2(skeletonTarget, skeletonSource, { ...retargetOptions });
			
		}

		/**
		 * @param {THREE.SkeletonHelper} helper
		 * @param {THREE.ColorRepresentation} color1
		 * @param {THREE.ColorRepresentation} color2
		 */
		export function setSkeletonHelperColors(helper, color1, color2) {
			const colors = helper.geometry.getAttribute("color")
			if (!(colors instanceof THREE.BufferAttribute)) throw new Error()

			const nLines = colors.count / 2 // each line has 2 colors

			for (let i = 0; i < nLines; ++i) {
				colors.set(_color.set(color1).toArray(), (i * 2 + 0) * colors.itemSize)
				colors.set(_color.set(color2).toArray(), (i * 2 + 1) * colors.itemSize)
			}

			colors.needsUpdate = true
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}
		</script>
	</body>
</html>
